<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Project_v2</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
    header { background: #003366; color: #fff; padding: 1rem 2rem; }
    main { padding: 1.5rem 2rem 3rem 2rem; }
    h1, h2, h3 { color: #003366; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 2rem; }
    th, td { border: 1px solid #ddd; padding: 0.5rem 0.75rem; text-align: left; }
    th { background: #f3f6f9; }
    pre { background: #f5f5f5; padding: 1rem; overflow-x: auto; }
    a { color: #003366; }
    .ret { color:#444; font-style: italic; }
  </style>
</head>
<body>
<header>
  <h1>Project_v2</h1>
  <p><a href="index.html">Overview</a></p>
</header>
<main>
  <h2>Method Summary</h2>
  <table>
    <tr><th>Method</th><th>Description / Signature</th></tr>
    <tr><td><a href="#sort">sort</a></td><td><code>static double[] sort(int size, double[] array)</code></td></tr>
    <tr><td><a href="#clearScreen">clearScreen</a></td><td><code>static void clearScreen()</code></td></tr>
    <tr><td><a href="#isTurkishLetter">isTurkishLetter</a></td><td><code>static boolean isTurkishLetter(char c)</code></td></tr>
    <tr><td><a href="#containsLetter">containsLetter</a></td><td><code>static boolean containsLetter(String text)</code></td></tr>
    <tr><td><a href="#optionA">optionA</a></td><td><code>static void optionA(Scanner user)</code></td></tr>
    <tr><td><a href="#zodiac_sign">zodiac_sign</a></td><td><code>static void zodiac_sign(int day, int month)</code></td></tr>
    <tr><td><a href="#age_and_zodiac">age_and_zodiac</a></td><td><code>static void age_and_zodiac(Scanner user)</code></td></tr>
    <tr><td><a href="#reverse_the_word">reverse_the_word</a></td><td><code>static String reverse_the_word(String word)</code></td></tr>
    <tr><td><a href="#reverse_the_text">reverse_the_text</a></td><td><code>static void reverse_the_text(Scanner user)</code></td></tr>
    <tr><td><a href="#optionB">optionB</a></td><td><code>static void optionB(Scanner user)</code></td></tr>
    <tr><td><a href="#prime_number_input">prime_number_input</a></td><td><code>static int prime_number_input(Scanner user)</code></td></tr>
    <tr><td><a href="#eratosthenes">eratosthenes</a></td><td><code>static List&lt;Integer&gt; eratosthenes(int n)</code></td></tr>
    <tr><td><a href="#sundaram">sundaram</a></td><td><code>static List&lt;Integer&gt; sundaram(int n)</code></td></tr>
    <tr><td><a href="#atkin">atkin</a></td><td><code>static List&lt;Integer&gt; atkin(int n)</code></td></tr>
    <tr><td><a href="#prime_number_output">prime_number_output</a></td><td><code>static void prime_number_output(Scanner user)</code></td></tr>
    <tr><td><a href="#evaluate_expression">evaluate_expression</a></td><td><code>static void evaluate_expression(Scanner user)</code></td></tr>
    <tr><td><a href="#isParenthesesBalanced">isParenthesesBalanced</a></td><td><code>static boolean isParenthesesBalanced(String expr)</code></td></tr>
    <tr><td><a href="#evalSimple">evalSimple</a></td><td><code>static double evalSimple(String expr)</code></td></tr>
    <tr><td><a href="#simplify">simplify</a></td><td><code>static String simplify(String expr)</code></td></tr>
    <tr><td><a href="#optionC">optionC</a></td><td><code>static void optionC(Scanner user)</code></td></tr>
    <tr><td><a href="#median">median</a></td><td><code>static double median(int size, double[] stat_arr)</code></td></tr>
    <tr><td><a href="#arith_mean">arith_mean</a></td><td><code>static double arith_mean(int size, double[] stat_arr)</code></td></tr>
    <tr><td><a href="#geo_mean">geo_mean</a></td><td><code>static Double geo_mean(int size, double[] stat_arr)</code></td></tr>
    <tr><td><a href="#formula">formula</a></td><td><code>static double formula(double[] arr, int index)</code></td></tr>
    <tr><td><a href="#harmonic_mean">harmonic_mean</a></td><td><code>static double harmonic_mean(int size, double[] stat_arr)</code></td></tr>
    <tr><td><a href="#stat_info_arr">stat_info_arr</a></td><td><code>static void stat_info_arr(Scanner user)</code></td></tr>
    <tr><td><a href="#euclid_dist">euclid_dist</a></td><td><code>static double euclid_dist(int[] array1, int[] array2)</code></td></tr>
    <tr><td><a href="#manhattan_dist">manhattan_dist</a></td><td><code>static int manhattan_dist(int[] array1, int[] array2)</code></td></tr>
    <tr><td><a href="#cos_similar">cos_similar</a></td><td><code>static double cos_similar(int[] array1, int[] array2)</code></td></tr>
    <tr><td><a href="#dist_btwn_arr">dist_btwn_arr</a></td><td><code>static void dist_btwn_arr(Scanner user)</code></td></tr>
    <tr><td><a href="#optionD">optionD</a></td><td><code>static void optionD(Scanner user)</code></td></tr>
    <tr><td><a href="#playGame">playGame</a></td><td><code>static void playGame(Scanner user, int cols, int rows, boolean vsComputer)</code></td></tr>
    <tr><td><a href="#initializeBoard">initializeBoard</a></td><td><code>static void initializeBoard(char[][] board)</code></td></tr>
    <tr><td><a href="#printBoard">printBoard</a></td><td><code>static void printBoard(char[][] board)</code></td></tr>
    <tr><td><a href="#placeDisc">placeDisc</a></td><td><code>static boolean placeDisc(char[][] board, int col, char disc)</code></td></tr>
    <tr><td><a href="#checkWin">checkWin</a></td><td><code>static boolean checkWin(char[][] board, char disc)</code></td></tr>
    <tr><td><a href="#isFull">isFull</a></td><td><code>static boolean isFull(char[][] board)</code></td></tr>
    <tr><td><a href="#getBestMove">getBestMove</a></td><td><code>static int getBestMove(char[][] board, int depth)</code></td></tr>
    <tr><td><a href="#minimax">minimax</a></td><td><code>static int minimax(char[][] board, int depth, boolean maximizingPlayer)</code></td></tr>
    <tr><td><a href="#copyBoard">copyBoard</a></td><td><code>static char[][] copyBoard(char[][] board)</code></td></tr>
    <tr><td><a href="#game_mode">game_mode</a></td><td><code>static void game_mode(Scanner user, int cols, int rows)</code></td></tr>
    <tr><td><a href="#selectionmenu">selectionmenu</a></td><td><code>static boolean selectionmenu(Scanner user)</code></td></tr>
    <tr><td><a href="#main">main</a></td><td><code>public static void main(String[] args)</code></td></tr>
  </table>

  <h2>Method Detail</h2>
  
  <h3 id="sort">sort</h3>
  <pre>static double[] sort(int size, double[] array)</pre>
  <p><strong>Description:</strong> In-place <em>selection sort</em> of the first <code>size</code> elements of <code>array</code> in ascending order.</p>
  <p><strong>Parameters:</strong> <code>size</code> – how many items to sort; <code>array</code> – numbers to sort.</p>
  <p class="ret"><strong>Returns:</strong> the same array reference, now sorted.</p>
  <hr/>

  <h3 id="clearScreen">clearScreen</h3>
  <pre>static void clearScreen()</pre>
  <p><strong>Description:</strong> Clears the terminal. Uses <code>cls</code> on Windows, ANSI escape codes on Unix; falls back to printing empty lines.</p>
  <hr/>

  <h3 id="isTurkishLetter">isTurkishLetter</h3>
  <pre>static boolean isTurkishLetter(char c)</pre>
  <p><strong>Description:</strong> Checks if a character is a Turkish-specific letter (ç, ğ, ı, İ, ö, ş, ü) or any Unicode letter.</p>
  <p class="ret"><strong>Returns:</strong> <code>true</code> if letter; otherwise <code>false</code>.</p>
  <hr/>

  <h3 id="containsLetter">containsLetter</h3>
  <pre>static boolean containsLetter(String text)</pre>
  <p><strong>Description:</strong> Scans the string and returns <code>true</code> if it contains at least one letter (including Turkish letters).</p>
  <hr/>

  <h3 id="optionA">optionA</h3>
  <pre>static void optionA(Scanner user)</pre>
  <p><strong>Description:</strong> Submenu “Primary School”: lets the user choose between Age &amp; Zodiac detection and Word Reverser; or return to main menu.</p>
  <hr/>

  <h3 id="zodiac_sign">zodiac_sign</h3>
  <pre>static void zodiac_sign(int day, int month)</pre>
  <p><strong>Description:</strong> Prints the Western zodiac sign for the given day/month with hard-coded date thresholds.</p>
  <hr/>

  <h3 id="age_and_zodiac">age_and_zodiac</h3>
  <pre>static void age_and_zodiac(Scanner user)</pre>
  <p><strong>Description:</strong> Prompts for birth date (<code>yyyy-MM-dd</code>), validates it’s not in the future, computes age as of today, and prints both zodiac sign and age.</p>
  <hr/>

  <h3 id="reverse_the_word">reverse_the_word</h3>
  <pre>static String reverse_the_word(String word)</pre>
  <p><strong>Description:</strong> Reverses only the <em>letter</em> characters in a word (including Turkish letters) while keeping non-letters in place.</p>
  <p class="ret"><strong>Returns:</strong> the transformed word.</p>
  <hr/>

  <h3 id="reverse_the_text">reverse_the_text</h3>
  <pre>static void reverse_the_text(Scanner user)</pre>
  <p><strong>Description:</strong> Reads a line, validates it’s non-empty and has letters, reverses each word using <code>reverse_the_word</code>, and prints the result.</p>
  <hr/>

  <h3 id="optionB">optionB</h3>
  <pre>static void optionB(Scanner user)</pre>
  <p><strong>Description:</strong> Submenu “Secondary School”: provides Prime Numbers demo and Step-by-step Expression evaluation; or return to main.</p>
  <hr/>

  <h3 id="prime_number_input">prime_number_input</h3>
  <pre>static int prime_number_input(Scanner user)</pre>
  <p><strong>Description:</strong> Prompts for an integer <code>n</code> with validation (12 ≤ n ≤ 1000). Handles non-integer input safely.</p>
  <p class="ret"><strong>Returns:</strong> the valid integer.</p>
  <hr/>

  <h3 id="eratosthenes">eratosthenes</h3>
  <pre>static List&lt;Integer&gt; eratosthenes(int n)</pre>
  <p><strong>Description:</strong> Sieve of Eratosthenes to generate primes up to <code>n</code>.</p>
  <hr/>

  <h3 id="sundaram">sundaram</h3>
  <pre>static List&lt;Integer&gt; sundaram(int n)</pre>
  <p><strong>Description:</strong> Sieve of Sundaram variant producing odd primes up to <code>n</code> (plus 2 if applicable).</p>
  <hr/>

  <h3 id="atkin">atkin</h3>
  <pre>static List&lt;Integer&gt; atkin(int n)</pre>
  <p><strong>Description:</strong> Sieve of Atkin implementation to compute primes up to <code>n</code>, using quadratic residue tests and square-free elimination.</p>
  <hr/>

  <h3 id="prime_number_output">prime_number_output</h3>
  <pre>static void prime_number_output(Scanner user)</pre>
  <p><strong>Description:</strong> Gets <code>n</code>, runs all three sieves, times them in milliseconds, and prints first/last few primes and timings.</p>
  <hr/>

  <h3 id="evaluate_expression">evaluate_expression</h3>
  <pre>static void evaluate_expression(Scanner user)</pre>
  <p><strong>Description:</strong> Reads an arithmetic expression using digits, <code>+ - x : *</code>, and parentheses; validates characters and balanced parentheses; normalizes <code>x</code> → <code>*</code> and <code>:</code> → <code>/</code>; then prints step-by-step simplification.</p>
  <hr/>

  <h3 id="isParenthesesBalanced">isParenthesesBalanced</h3>
  <pre>static boolean isParenthesesBalanced(String expr)</pre>
  <p><strong>Description:</strong> Linear scan counter to ensure parentheses are balanced (never dips negative; ends at zero).</p>
  <hr/>

  <h3 id="evalSimple">evalSimple</h3>
  <pre>static double evalSimple(String expr)</pre>
  <p><strong>Description:</strong> Evaluates a parenthesis-free expression with real numbers, unary minus, and operators <code>+ - * /</code>, honoring standard precedence (* and / before + and -).</p>
  <p class="ret"><strong>Returns:</strong> numeric value of the expression.</p>
  <hr/>

  <h3 id="simplify">simplify</h3>
  <pre>static String simplify(String expr)</pre>
  <p><strong>Description:</strong> Recursively evaluates innermost parentheses using <code>evalSimple</code>, printing intermediate results until no parentheses remain.</p>
  <p class="ret"><strong>Returns:</strong> final numeric value as a string.</p>
  <hr/>

  <h3 id="optionC">optionC</h3>
  <pre>static void optionC(Scanner user)</pre>
  <p><strong>Description:</strong> Submenu “High School”: shows statistical calculations for a numeric array and distances between two integer arrays.</p>
  <hr/>

  <h3 id="median">median</h3>
  <pre>static double median(int size, double[] stat_arr)</pre>
  <p><strong>Description:</strong> Computes median of a sorted array slice of length <code>size</code> (handles even/odd sizes).</p>
  <hr/>

  <h3 id="arith_mean">arith_mean</h3>
  <pre>static double arith_mean(int size, double[] stat_arr)</pre>
  <p><strong>Description:</strong> Arithmetic mean (average) over first <code>size</code> elements.</p>
  <hr/>

  <h3 id="geo_mean">geo_mean</h3>
  <pre>static Double geo_mean(int size, double[] stat_arr)</pre>
  <p><strong>Description:</strong> Geometric mean for strictly positive numbers; returns <code>null</code> if any value ≤ 0.</p>
  <hr/>

  <h3 id="formula">formula</h3>
  <pre>static double formula(double[] arr, int index)</pre>
  <p><strong>Description:</strong> Recursive helper that sums reciprocals <code>Σ (1/arr[i])</code> from <code>index</code> to end.</p>
  <hr/>

  <h3 id="harmonic_mean">harmonic_mean</h3>
  <pre>static double harmonic_mean(int size, double[] stat_arr)</pre>
  <p><strong>Description:</strong> Harmonic mean = <code>size / Σ(1/x)</code>, using <code>formula</code> to compute the denominator.</p>
  <hr/>

  <h3 id="stat_info_arr">stat_info_arr</h3>
  <pre>static void stat_info_arr(Scanner user)</pre>
  <p><strong>Description:</strong> Reads array length (1–20) and values, sorts them, and prints median, arithmetic mean, geometric mean (or note if undefined), and harmonic mean.</p>
  <hr/>

  <h3 id="euclid_dist">euclid_dist</h3>
  <pre>static double euclid_dist(int[] array1, int[] array2)</pre>
  <p><strong>Description:</strong> Euclidean distance between two equal-length integer vectors: <code>sqrt( Σ (aᵢ−bᵢ)² )</code>.</p>
  <hr/>

  <h3 id="manhattan_dist">manhattan_dist</h3>
  <pre>static int manhattan_dist(int[] array1, int[] array2)</pre>
  <p><strong>Description:</strong> Manhattan (L1) distance: <code>Σ |aᵢ−bᵢ|</code>.</p>
  <hr/>

  <h3 id="cos_similar">cos_similar</h3>
  <pre>static double cos_similar(int[] array1, int[] array2)</pre>
  <p><strong>Description:</strong> Cosine similarity: <code>(a·b)/(|a||b|)</code>. Returns 0 if either vector has zero norm.</p>
  <hr/>

  <h3 id="dist_btwn_arr">dist_btwn_arr</h3>
  <pre>static void dist_btwn_arr(Scanner user)</pre>
  <p><strong>Description:</strong> Prompts for dimension (1–20), reads two integer vectors, then prints Manhattan distance, Euclidean distance, and cosine similarity.</p>
  <hr/>

  <h3 id="optionD">optionD</h3>
  <pre>static void optionD(Scanner user)</pre>
  <p><strong>Description:</strong> Submenu “University”: lets the user select a Connect 4 board size (5×4, 6×5, 7×6) and proceeds to game mode selection.</p>
  <hr/>

  <h3 id="playGame">playGame</h3>
  <pre>static void playGame(Scanner user, int cols, int rows, boolean vsComputer)</pre>
  <p><strong>Description:</strong> Core loop for Connect 4. Handles input (or AI move), updates board, prints it, detects wins/draws, and manages turn switching based on mode.</p>
  <p><strong>Notes:</strong> AI uses <code>getBestMove</code> with <code>MAX_DEPTH</code> via <code>minimax</code>.</p>
  <hr/>

  <h3 id="initializeBoard">initializeBoard</h3>
  <pre>static void initializeBoard(char[][] board)</pre>
  <p><strong>Description:</strong> Fills the board with <code>'.'</code> (empty cells).</p>
  <hr/>

  <h3 id="printBoard">printBoard</h3>
  <pre>static void printBoard(char[][] board)</pre>
  <p><strong>Description:</strong> Renders the board with borders, colored discs (X for player, O for AI), and column numbers.</p>
  <hr/>

  <h3 id="placeDisc">placeDisc</h3>
  <pre>static boolean placeDisc(char[][] board, int col, char disc)</pre>
  <p><strong>Description:</strong> Drops a disc into the given column from the top, settling at the lowest empty cell.</p>
  <p class="ret"><strong>Returns:</strong> <code>true</code> if placed; <code>false</code> if column is full.</p>
  <hr/>

  <h3 id="checkWin">checkWin</h3>
  <pre>static boolean checkWin(char[][] board, char disc)</pre>
  <p><strong>Description:</strong> Checks horizontal, vertical, and both diagonal directions for four-in-a-row for the given disc.</p>
  <hr/>

  <h3 id="isFull">isFull</h3>
  <pre>static boolean isFull(char[][] board)</pre>
  <p><strong>Description:</strong> Returns <code>true</code> if the top row has no empty cells, i.e., board is full (draw if no winner).</p>
  <hr/>

  <h3 id="getBestMove">getBestMove</h3>
  <pre>static int getBestMove(char[][] board, int depth)</pre>
  <p><strong>Description:</strong> Tries each valid column for the AI, scores it using <code>minimax</code> to limited depth, and picks the best column index.</p>
  <hr/>

  <h3 id="minimax">minimax</h3>
  <pre>static int minimax(char[][] board, int depth, boolean maximizingPlayer)</pre>
  <p><strong>Description:</strong> Simple minimax evaluation for Connect 4 with terminal checks (AI win = +1000; player win = −1000; draw or depth 0 = 0). No heuristic beyond win/draw.</p>
  <hr/>

  <h3 id="copyBoard">copyBoard</h3>
  <pre>static char[][] copyBoard(char[][] board)</pre>
  <p><strong>Description:</strong> Deep copies the 2D board array for safe simulation in search.</p>
  <hr/>

  <h3 id="game_mode">game_mode</h3>
  <pre>static void game_mode(Scanner user, int cols, int rows)</pre>
  <p><strong>Description:</strong> Asks whether to play Single Player (vs AI) or Two-player, then launches <code>playGame</code> or returns.</p>
  <hr/>

  <h3 id="selectionmenu">selectionmenu</h3>
  <pre>static boolean selectionmenu(Scanner user)</pre>
  <p><strong>Description:</strong> Main menu dispatcher for the four education levels (A–D) and termination (E).</p>
  <p class="ret"><strong>Returns:</strong> <code>false</code> only if user chooses to terminate; otherwise <code>true</code>.</p>
  <hr/>

  <h3 id="main">main</h3>
  <pre>public static void main(String[] args)</pre>
  <p><strong>Description:</strong> Entry point. Prints colored ASCII banner, then repeatedly shows the main menu until the user exits.</p>
  <hr/>

  <h2>Source</h2>
  <pre>import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

public class Project_v2 {

    static final String GREEN = &quot;\u001B[32m&quot;;
    static final String BLUE = &quot;\u001B[34m&quot;;
    static final String MAGENTA = &quot;\u001B[35m&quot;;
    static final String WHITE = &quot;\u001B[37m&quot;;
    static final String RESET = &quot;\u001B[0m&quot;;
    static final String RED = &quot;\u001B[31m&quot;;
    static final String YELLOW = &quot;\u001B[33m&quot;;
    static final String CYAN = &quot;\u001B[36m&quot;;

    static final char PLAYER = &#x27;X&#x27;;
    static final char AI = &#x27;O&#x27;;
    static final int MAX_DEPTH = 3;

    static double[] sort(int size, double[] array) {
        for (int i = 0; i &lt; size - 1; i++) {
            int minVal = i;
            for (int j = i + 1; j &lt; size; j++) {
                if (array[j] &lt; array[minVal]) {
                    minVal = j;
                }
            }
            double temp = array[i];
            array[i] = array[minVal];
            array[minVal] = temp;
        }
        return array;
    }

    static void clearScreen() {
        try {
            if (System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;windows&quot;)) {
                new ProcessBuilder(&quot;cmd&quot;, &quot;/c&quot;, &quot;cls&quot;).inheritIO().start().waitFor();
            } else {
                System.out.print(&quot;\033[H\033[2J&quot;);
                System.out.flush();
            }
        } catch (Exception e) {

            for (int i = 0; i&lt;50; i++){
                System.out.println();
            }
        }
    }

    static boolean isTurkishLetter(char c) {

        String turkishLetters = &quot;çÇğĞıİöÖşŞüÜ&quot;;
        return turkishLetters.indexOf(c) != -1 || Character.isLetter(c);
    }


    static boolean containsLetter(String text) {
        for (int i = 0; i &lt; text.length(); i++) {
            char c = text.charAt(i);
            // у тебя уже есть isTurkishLetter(...) — давай её и используем
            if (isTurkishLetter(c)) {
                return true;
            }
        }
        return false;
    }


    static void optionA(Scanner user) {
        boolean breaker = true;

        while (breaker) {

            System.out.println(&quot;[A]Age and Zodiac Sign Detector\n&quot;);
            System.out.println(&quot;[B]Reverse the Words\n&quot;);
            System.out.println(&quot;[C]Return to Main Menu\n&quot;);
            char charinput = Character.toUpperCase(user.next().charAt(0));
            user.nextLine();
            clearScreen();

            switch (charinput) {
                case &#x27;A&#x27;:

                    age_and_zodiac(user);

                    break;
                case &#x27;B&#x27;:
                    reverse_the_text(user);

                    break;
                case &#x27;C&#x27;:

                    breaker = false;
                    break;

                default:
                    System.err.println(&quot;Invalid input! Please enter a single character: A, B, C.\n&quot;);

            }
        }

    }

    static void zodiac_sign(int day, int month) {

        switch (month) {

            case 1:
                if (day &gt;= 20) {
                    System.out.println(&quot;Your sign is Aquarius\n&quot;);
                } else {
                    System.out.println(&quot;Your sign is Capricon\n&quot;);
                }
                break;
            case 2:
                if (day &lt;= 18) {
                    System.out.println(&quot;Your sign is Aquarius\n&quot;);
                } else {
                    System.out.println(&quot;Your sign is Pisces\n&quot;);
                }
                break;
            case 3:
                if (day &lt;= 20) {
                    System.out.println(&quot;Your sign is Pisces\n&quot;);
                } else {
                    System.out.println(&quot;Your sign is Aries\n&quot;);
                }
                break;
            case 4:
                if (day &lt;= 19) {
                    System.out.println(&quot;Your sign is Aries&quot;);
                } else {
                    System.out.println(&quot;Your sign is Taurus&quot;);
                }
                break;
            case 5:
                if (day &lt;= 20) {
                    System.out.println(&quot;Your sign is Taurus\n&quot;);
                } else {
                    System.out.println(&quot;Your sign is Gemini\n&quot;);
                }
                break;
            case 6:
                if (day &lt;= 21) {
                    System.out.println(&quot;Your sign is Gemini\n&quot;);
                } else {
                    System.out.println(&quot;Your sign is Cancer\n&quot;);
                }
                break;
            case 7:
                if (day &lt;= 22) {
                    System.out.println(&quot;Your sign is Cancer\n&quot;);
                } else {
                    System.out.println(&quot;Your sign is Leo\n&quot;);
                }
                break;
            case 8:
                if (day &lt;= 22) {
                    System.out.println(&quot;Your sign is Leo\n&quot;);
                } else {
                    System.out.println(&quot;Your sign is Virgo\n&quot;);
                }
                break;
            case 9:
                if (day &lt;= 22) {
                    System.out.println(&quot;Your sign is Virgo\n&quot;);
                } else {
                    System.out.println(&quot;Your sign is Libra\n&quot;);
                }
                break;
            case 10:
                if (day &lt;= 22) {
                    System.out.println(&quot;Your sign is Libra\n&quot;);
                } else {
                    System.out.println(&quot;Your sign is Scorpio\n&quot;);
                }
                break;
            case 11:
                if (day &lt;= 21) {
                    System.out.println(&quot;Your sign is Scorpio\n&quot;);
                } else {
                    System.out.println(&quot;Your sign is Sagittarius\n&quot;);
                }
                break;
            case 12:
                if (day &lt;= 21) {
                    System.out.println(&quot;Your sign is Sagittarius\n&quot;);
                } else {
                    System.out.println(&quot;Your sign is Capricorn\n&quot;);
                }
                break;
            default:
                System.err.println(&quot;Something went wrong\n&quot;);
        }
    }
    static void age_and_zodiac(Scanner user) {
        while (true) {
            System.out.println(&quot;Please enter your birthday: yyyy-MM-dd&quot;);
            String user_birth = user.nextLine().trim();

            try {
                LocalDate time = LocalDate.now();
                LocalDate birthDay = LocalDate.parse(user_birth, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));
                int user_year = birthDay.getYear();
                int user_month = birthDay.getMonthValue();
                int user_day = birthDay.getDayOfMonth();

                int year = time.getYear();
                int month = time.getMonthValue();
                int day = time.getDayOfMonth();

                boolean bornInFuture = false;

                if (user_year &gt; year) {
                    bornInFuture = true;
                } else if (user_year == year &amp;&amp; user_month &gt; month) {
                    bornInFuture = true;
                } else if (user_year == year &amp;&amp; user_month == month &amp;&amp; user_day &gt; day) {
                    bornInFuture = true;
                }

                if (bornInFuture) {
                    System.err.println(&quot;You can&#x27;t be born in the future!\n&quot;);

                    continue;
                }

                int age = year - user_year;

                if (month &lt; user_month || (month == user_month &amp;&amp; day &lt; user_day)) {
                    age--;
                }

                zodiac_sign(user_day, user_month);
                System.out.println(&quot;Your age is: &quot; + age);
                // тут всё ок — можно выйти из цикла и вернуться в меню
                break;

            } catch (Exception e) {
                System.err.println(&quot;\nInvalid format! Please type in: (yyyy-MM-dd)\n&quot;);

            }
        }
    }


    static String reverse_the_word(String word) {

        char[] chars = word.toCharArray();
        int left = 0;
        int right = word.length() - 1;

        while (left &lt; right) {

            if (!isTurkishLetter(chars[left])) {
                left++;
            } else if (!isTurkishLetter(chars[right])) {
                right--;
            } else {

                char temp = chars[left];
                chars[left] = chars[right];
                chars[right] = temp;
                left++;
                right--;
            }
        }
        return new String(chars);
    }

    static void reverse_the_text(Scanner user) {
        while (true) {
            System.out.println(&quot;Enter text to reverse:\n&quot;);
            String text = user.nextLine();


            if (text.trim().isEmpty()) {
                System.err.println(&quot;Invalid input! The text cannot be empty.\n&quot;);
                continue;
            }


            if (!containsLetter(text)) {
                System.err.println(&quot;Invalid input! Please enter a text that contains letters, not only digits.\n&quot;);
                continue;
            }


            String[] words = text.split(&quot; &quot;);
            StringBuilder result = new StringBuilder();

            for (int i = 0; i &lt; words.length; i++) {
                result.append(reverse_the_word(words[i]));
                if (i &lt; words.length - 1) {
                    result.append(&quot; &quot;);
                }
            }

            System.out.println(&quot;Reversed Text:\n&quot;);
            System.out.println(result.toString());

            break;
        }
    }

    static void optionB(Scanner user) {
        boolean breaker = true;
        while (breaker) {
            System.out.println(&quot;[A]Prime Numbers\n&quot;);
            System.out.println(&quot;[B]Step-by-step Eveluation of Expression\n&quot;);
            System.out.println(&quot;[C]Return to Main Menu\n&quot;);
            char charinput = Character.toUpperCase(user.next().charAt(0));
            user.nextLine();
            clearScreen();

            switch (charinput) {
                case &#x27;A&#x27;:
                    prime_number_output(user);
                    break;
                case &#x27;B&#x27;:
                    evaluate_expression(user);
                    break;
                case &#x27;C&#x27;:
                    breaker = false;
                    break;
                default:
                    System.err.println(&quot;Invalid input! Please enter a signle character: A, B, C\n&quot;);
            }
        }
    }

    static int prime_number_input(Scanner user) {
        System.out.println(&quot;Enter an integer n &gt;= 12:\n&quot;);
        int n, max = 1000;
        while (true) {
            try {
                n = user.nextInt();
            } catch (Exception e) {
                System.err.println(&quot;Invalid input! Please enter an integer.\n&quot;);
                user.nextLine();
                continue;
            }
            if (n &gt; max) {
                System.err.println(&quot;Too large! limit is 1000\n&quot;);
                System.out.println(&quot;Please enter a value between 12 and 1000:\n&quot;);
                continue;
            }

            if (n &lt; 12) {
                System.err.println(&quot;Invalid input! Please enter a number ≥ 12.\n&quot;);
                continue;
            }
            return n;

        }

    }

    static List&lt;Integer&gt; eratosthenes(int n) {
        boolean[] isPrime = new boolean[n + 1];
        for (int i = 1; i &lt;= n; i++) {
            isPrime[i] = true;
        }
        for (int i = 2; i * i &lt;= n; i++) {
            if (isPrime[i] == true) {
                for (int j = i * i; j &lt;= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        List&lt;Integer&gt; primes = new ArrayList&lt;&gt;();
        if (n &gt;= 2)
            primes.add(2);
        if (n &gt;= 3)
            primes.add(3);

        for (int i = 4; i &lt;= n; i++) {
            if (isPrime[i] == true) {
                primes.add(i);
            }
        }
        return primes;

    }

    static List&lt;Integer&gt; sundaram(int n) {
        boolean[] not_Prime = new boolean[n + 1];
        // find the correct index
        for (int i = 1; i &lt;= (n - 2) / 2; i++) {
            for (int j = i; i + j + 2 * i * j &lt;= (n - 2) / 2; j++) {
                not_Prime[i + j + 2 * i * j] = true;
            }
        }
        List&lt;Integer&gt; primes = new ArrayList&lt;&gt;();
        if (n &gt;= 2)
            primes.add(2);
        for (int i = 1; i &lt;= (n - 2) / 2; i++) {
            if (not_Prime[i] == false)
                // add prime numbers except the correct index
                primes.add(2 * i + 1);
        }
        return primes;

    }

    static List&lt;Integer&gt; atkin(int n) {
        boolean[] isPrime = new boolean[n + 1];
        int limit = (int) Math.sqrt(n);

        for (int x = 1; x &lt;= limit; x++) {
            for (int y = 1; y &lt;= limit; y++) {
                int number = 4 * x * x + y * y;
                if (number &lt;= n &amp;&amp; (number % 12 == 1 || number % 12 == 5)) {
                    isPrime[number] = !isPrime[number];
                }

                number = 3 * x * x + y * y;
                if (number &lt;= n &amp;&amp; number % 12 == 7) {
                    isPrime[number] = !isPrime[number];
                }

                number = 3 * x * x - y * y;
                if (x &gt; y &amp;&amp; number &lt;= n &amp;&amp; number % 12 == 11) {
                    isPrime[number] = !isPrime[number];
                }
            }
        }
        for (int i = 5; i &lt;= limit; i++) {
            if (isPrime[i]) {
                int square = i * i;
                for (int j = square; j &lt;= n; j += square) {
                    isPrime[j] = false;
                }
            }
        }
        List&lt;Integer&gt; primes = new ArrayList&lt;&gt;();
        if (n &gt;= 2) {
            primes.add(2);
        }
        if (n &gt;= 3) {
            primes.add(3);
        }

        for (int i = 5; i &lt;= n; i++) {
            if (isPrime[i]) {
                primes.add(i);
            }
        }

        return primes;
    }


    static void prime_number_output(Scanner user) {
        int n = prime_number_input(user);
        // eratosthenes
        long startE = System.nanoTime();
        List&lt;Integer&gt; eratosthenes_algorithm = eratosthenes(n);
        long endE = System.nanoTime();
        double eratosthenes_time = (endE - startE) / 1_000_000.0;
        // sundaram
        long startS = System.nanoTime();
        List&lt;Integer&gt; sundaram_algorithm = sundaram(n);
        long endS = System.nanoTime();
        double sundaram_time = (endS - startS) / 1_000_000.0;

        // atkin
        long startA = System.nanoTime();
        List&lt;Integer&gt; atkin_algorithm = atkin(n);
        long endA = System.nanoTime();
        double atkin_time = (endA - startA) / 1_000_000.0;
        System.out.println(&quot;========Prime Number Genreation ========\n&quot;);

        System.out.println(&quot;\nEratosthenes algorithm: \nfirst 3: &quot; + eratosthenes_algorithm.subList(0, 3) + &quot;\nLast 2: &quot;
                + eratosthenes_algorithm.subList(eratosthenes_algorithm.size() - 2, eratosthenes_algorithm.size()));
        System.out.println(&quot;Execution time: &quot; + eratosthenes_time);
        System.out.println(&quot;\nSundaram algorithm: \nfirst 3: &quot; + sundaram_algorithm.subList(0, 3) + &quot;\nLast 2: &quot;
                + sundaram_algorithm.subList(sundaram_algorithm.size() - 2, sundaram_algorithm.size()));
        System.out.println(&quot;Execution time: &quot; + sundaram_time);
        System.out.println(&quot;\nAtkin algorithm: &quot; + &quot;\nfirst 3: &quot; + atkin_algorithm.subList(0, 3) + &quot;\nLast 2: &quot;
                + atkin_algorithm.subList(atkin_algorithm.size() - 2, atkin_algorithm.size()) + &quot;\n&quot;);
        System.out.println(&quot;Execution time: &quot; + atkin_time);
        user.nextLine();
    }


    static void evaluate_expression(Scanner user) {
        while (true) {
            System.out.println(&quot;Enter an expression (use + - x : and parentheses):\n&quot;);
            String expr = user.nextLine();


            expr = expr.replaceAll(&quot;\\s+&quot;, &quot;&quot;);


            if (!expr.matches(&quot;[0-9()+\\-x*/:]+&quot;)) {
                System.err.println(&quot;Error: Only digits, + - x : and () are allowed.\n&quot;);

                continue;
            }


            if (!isParenthesesBalanced(expr)) {
                System.err.println(&quot;Error: Parentheses are not balanced.\n&quot;);

                continue;
            }


            expr = expr.replace(&quot;x&quot;, &quot;*&quot;).replace(&quot;:&quot;, &quot;/&quot;);

            System.out.println(&quot;Solving step by step...\n&quot;);


            System.out.println(&quot;= &quot; + simplify(expr));


            break;
        }
    }


    static boolean isParenthesesBalanced(String expr) {
        int counter = 0;
        for (char c : expr.toCharArray()) {
            if (c == &#x27;(&#x27;)
                counter++;
            else if (c == &#x27;)&#x27;)
                counter--;

            if (counter &lt; 0)
                return false;
        }
        return counter == 0;
    }

    static double evalSimple(String expr) {
        List&lt;Double&gt; numbers = new ArrayList&lt;&gt;();
        List&lt;Character&gt; ops = new ArrayList&lt;&gt;();
        StringBuilder currentNumber = new StringBuilder();

        for (int i = 0; i &lt; expr.length(); i++) {
            char c = expr.charAt(i);

            if (Character.isDigit(c) || c == &#x27;.&#x27;) {
                currentNumber.append(c);
            } else if (c == &#x27;-&#x27; &amp;&amp; (i == 0 || &quot;+-*/(&quot;.indexOf(expr.charAt(i - 1)) != -1)) {
                // unary minus
                currentNumber.append(c);
            } else {
                numbers.add(Double.parseDouble(currentNumber.toString()));
                currentNumber.setLength(0);
                ops.add(c);
            }
        }
        numbers.add(Double.parseDouble(currentNumber.toString()));


        for (int i = 0; i &lt; ops.size();) {
            char op = ops.get(i);
            if (op == &#x27;*&#x27; || op == &#x27;/&#x27;) {
                double result = (op == &#x27;*&#x27;) ? numbers.get(i) * numbers.get(i + 1)
                        : numbers.get(i) / numbers.get(i + 1);
                numbers.set(i, result);
                numbers.remove(i + 1);
                ops.remove(i);
            } else {
                i++;
            }
        }


        double result = numbers.get(0);
        for (int i = 0; i &lt; ops.size(); i++) {
            if (ops.get(i) == &#x27;+&#x27;)
                result += numbers.get(i + 1);
            else
                result -= numbers.get(i + 1);
        }

        return result;
    }


    static String simplify(String expr) {
        int open = expr.lastIndexOf(&#x27;(&#x27;);
        if (open != -1) {
            int close = expr.indexOf(&#x27;)&#x27;, open);
            String inside = expr.substring(open + 1, close);

            double value = evalSimple(inside);

            // replace the parentheses with the evaluated result
            String newExpr = expr.substring(0, open) + value + expr.substring(close + 1);

            System.out.println(&quot;= &quot; + newExpr);

            return simplify(newExpr);
        }


        double finalVal = evalSimple(expr);
        System.out.println(&quot;= &quot; + finalVal);
        return String.valueOf(finalVal);
    }

    static void optionC(Scanner user) {
        boolean breaker = true;

        while (breaker) {
            System.out.println(&quot;\n[A] Statistical information about an Array&quot;);
            System.out.println(&quot;[B] Distance between Two Arrays\n&quot;);
            System.out.println(&quot;[C] Return to Main Menu\n&quot;);
            char charinput = Character.toUpperCase(user.next().charAt(0));
            user.nextLine();
            clearScreen();
            switch (charinput) {
                case &#x27;A&#x27;:
                    stat_info_arr(user);
                    break;
                case &#x27;B&#x27;:
                    dist_btwn_arr(user);
                    break;
                case &#x27;C&#x27;:
                    breaker = false;
                    break;
                default:
                    System.err.println(&quot;Invalid input! Please choose again.\n&quot;);
            }
        }
    }

    static double median(int size, double[] stat_arr) {
        if (size % 2 == 0) {
            return (stat_arr[size / 2 - 1] + stat_arr[size / 2]) / 2.0;
        } else {
            return stat_arr[size / 2];
        }
    }

    static double arith_mean(int size, double[] stat_arr) {
        double sum = 0;
        for (int i = 0; i &lt; size; i++) {
            sum += stat_arr[i];
        }
        return sum / size;
    }

    static Double geo_mean(int size, double[] stat_arr) {
        double product = 1.0;
        for (int i = 0; i &lt; size; i++) {
            if (stat_arr[i] &lt;= 0) {
                return null;
            }
            product *= stat_arr[i];
        }
        return Math.pow(product, 1.0 / size);
    }

    static double formula(double[] arr, int index) {
        if (index == arr.length) {
            return 0;
        }
        return (1.0 / arr[index]) + formula(arr, index + 1);
    }

    static double harmonic_mean(int size, double[] stat_arr) {
        double sum = formula(stat_arr, 0);
        return size / sum;
    }

    static void stat_info_arr(Scanner user) {
        int size = 0;

        while (true) {
            System.out.print(&quot;Enter the array size (1-20): \n&quot;);
            if (user.hasNextInt()) {
                size = user.nextInt();
                if (size &gt; 0 &amp;&amp; size &lt;= 20) {
                    break;
                } else {
                    System.err.println(&quot;Invalid size! Must be between 1 and 20.\n&quot;);
                }
            } else {
                System.err.println(&quot;Invalid input! Enter a number.\n&quot;);
                user.next();
            }
        }
        double[] stat_arr = new double[size];
        int count = 1;
        for (int i = 0; i &lt; size; i++) {
            System.out.println(&quot;Enter the &quot; + count + &quot; number&quot;);
            stat_arr[i] = user.nextDouble();
            count++;
        }

        user.nextLine();

        sort(size, stat_arr);

        System.out.println(&quot;Median: &quot; + median(size, stat_arr));
        System.out.println(&quot;Arithmetic mean: &quot; + arith_mean(size, stat_arr));
        Double gmean = geo_mean(size, stat_arr);
        if (gmean == null) {
            System.out.println(&quot;Geometric mean: Not defined (contains non-positive numbers)&quot;);
        } else {
            System.out.println(&quot;Geometric mean: &quot; + gmean);
        }
        System.out.println(&quot;Harmonic mean: &quot; + harmonic_mean(size, stat_arr));
    }

    static double euclid_dist(int[] array1, int[] array2) {
        double sum = 0;
        for (int i = 0; i &lt; array1.length; i++) {
            sum += Math.pow(array1[i] - array2[i], 2);
        }
        return Math.sqrt(sum);
    }

    static int manhattan_dist(int[] array1, int[] array2) {
        int sum = 0;
        for (int i = 0; i &lt; array1.length; i++) {
            sum += Math.abs(array1[i] - array2[i]);
        }
        return sum;
    }

    static double cos_similar(int[] array1, int[] array2) {
        double dotProduct = 0;
        double normA = 0;
        double normB = 0;

        for (int i = 0; i &lt; array1.length; i++) {
            dotProduct += array1[i] * array2[i];
            normA += Math.pow(array1[i], 2);
            normB += Math.pow(array2[i], 2);
        }

        if (normA == 0 || normB == 0) {
            return 0.0;
        }

        return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
    }

    static void dist_btwn_arr(Scanner user) {
        int dimension = 0;
        while (true) {
            System.out.println(&quot;Enter the dimension (1-20): \n&quot;);
            if (!user.hasNextInt()) {
                System.err.println(&quot;Invalid input! Please enter a number.\n&quot;);
                user.nextLine();
                continue;
            }

            dimension = user.nextInt();
            user.nextLine();

            if (dimension &lt;= 0) {
                System.err.println(&quot;Dimension must be positive!\n&quot;);
            } else if (dimension &gt; 20) {
                System.err.println(&quot;Dimension cannot be more than 20!\n&quot;);
            } else {
                break;
            }
        }
        int[] array1 = new int[dimension];
        int[] array2 = new int[dimension];
        for (int i = 0; i &lt; dimension; i++) {
            System.out.println(&quot;Enter the &quot; + (i + 1) + &quot;st&quot; + &quot; element of the array 1: &quot;);
            int number = user.nextInt();
            array1[i] = number;
        }
        for (int i = 0; i &lt; dimension; i++) {
            System.out.println(&quot;Enter the &quot; + (i + 1) + &quot;st&quot; + &quot; element of the array 2: &quot;);
            int number = user.nextInt();
            array2[i] = number;
        }

        user.nextLine();

        System.out.println(&quot;Manhattan distance: &quot; + manhattan_dist(array1, array2));
        System.out.println(&quot;Euclidean distance: &quot; + euclid_dist(array1, array2));
        System.out.println(&quot;Cosine similarity: &quot; + cos_similar(array1, array2));

        System.out.println(Arrays.toString(array1));
        System.out.println(Arrays.toString(array2));
    }

    static void optionD(Scanner user) {
        boolean breaker = true;

        while (breaker) {
            System.out.println(&quot;This is game Connect 4, please choose the size of the board: \n&quot;);
            System.out.println(&quot;[A]5 X 4&quot;);
            System.out.println(&quot;[B]6 X 5&quot;);
            System.out.println(&quot;[C]7 X 6&quot;);
            System.out.println(&quot;[D]Return to Main Menu&quot;);
            char charinput = Character.toUpperCase(user.next().charAt(0));
            user.nextLine();
            clearScreen();
            switch (charinput) {
                case &#x27;A&#x27;:
                    game_mode(user, 5, 4);
                    break;
                case &#x27;B&#x27;:
                    game_mode(user, 6, 5);
                    break;
                case &#x27;C&#x27;:
                    game_mode(user, 7, 6);
                    break;
                case &#x27;D&#x27;:
                    breaker = false;
                    break;
                default:
                    System.err.println(&quot;Invalid input! Please choose again.\n&quot;);
            }
        }
    }

    static void playGame(Scanner user, int cols, int rows, boolean vsComputer) {
        char[][] board = new char[rows][cols];
        initializeBoard(board);
        boolean playerOneTurn = true;
        boolean gameOver = false;

        while (!gameOver) {

            String currentPlayer = playerOneTurn ? &quot;Player 1&quot; : &quot;Player 2&quot;);
            System.out.println(currentPlayer + &quot;, choose a column (1-&quot; + cols + &quot;) or Q to quit: &quot;);

            String input = user.nextLine().trim();


            if (input.equalsIgnoreCase(&quot;Q&quot;)) {
                System.out.println(currentPlayer + &quot; quit the game. Exiting...\n&quot;);
                break;
            }

            int chosenColumn;
            try {
                chosenColumn = Integer.parseInt(input) - 1;
            } catch (NumberFormatException e) {
                System.err.println(&quot;Invalid input! Please enter a number or Q to quit.\n&quot;);
                continue;
            }

            char currentDisc = playerOneTurn ? PLAYER : &#x27;O&#x27;;
            boolean validMove = (chosenColumn &gt;= 0 &amp;&amp; chosenColumn &lt; cols)
                    &amp;&amp; placeDisc(board, chosenColumn, currentDisc);

            if (!validMove) {
                System.err.println(&quot;Column full or invalid! Try again.\n&quot;);
                continue;
            }

            // If vsComputer and it&#x27;s Player 1&#x27;s turn, make the computer move immediately
            if (vsComputer &amp;&amp; playerOneTurn) {
                int aiChosenColumn = getBestMove(board, MAX_DEPTH);
                placeDisc(board, aiChosenColumn, AI);
            }

            // Print the board after moves
            printBoard(board);

            // Check for win/draw
            if (checkWin(board, PLAYER)) {
                System.out.println(&quot;Player 1 wins!&quot;);
                gameOver = true;
            } else if (checkWin(board, AI) &amp;&amp; vsComputer) {
                System.out.println(&quot;Computer wins!&quot;);
                gameOver = true;
            } else if (!vsComputer &amp;&amp; checkWin(board, &#x27;O&#x27;)) {
                System.out.println(&quot;Player 2 wins!&quot;);
                gameOver = true;
            } else if (isFull(board)) {
                System.out.println(&quot;It&#x27;s a draw!&quot;);
                gameOver = true;
            }

            // Switch turn only in 2-player mode
            if (!vsComputer)
                playerOneTurn = !playerOneTurn;
        }
    }

    static void initializeBoard(char[][] board) {
        for (int i = 0; i &lt; board.length; i++)
            for (int j = 0; j &lt; board[0].length; j++)
                board[i][j] = &#x27;.&#x27;;
    }

    static void printBoard(char[][] board) {
        int rows = board.length;
        int cols = board[0].length;

        // Top border
        System.out.print(&quot;  &quot;);
        for (int c = 0; c &lt; cols; c++) {
            System.out.print(&quot;===&quot;); // each cell width = 3
        }
        System.out.println(&quot;=&quot;);

        // Board rows
        for (int r = 0; r &lt; rows; r++) {
            System.out.print(&quot;|&quot;);
            for (int c = 0; c &lt; cols; c++) {
                char cell = board[r][c];
                if (cell == PLAYER) {
                    System.out.print(&quot; &quot; + RED + &quot;X&quot; + RESET + &quot; &quot;);
                } else if (cell == AI) {
                    System.out.print(&quot; &quot; + YELLOW + &quot;O&quot; + RESET + &quot; &quot;);
                } else {
                    System.out.print(&quot; . &quot;);
                }
            }
            System.out.println(&quot;|&quot;);
        }

        // Bottom border
        System.out.print(&quot;  &quot;);
        for (int c = 0; c &lt; cols; c++) {
            System.out.print(&quot;===&quot;);
        }
        System.out.println(&quot;=&quot;);

        // Column numbers
        System.out.print(&quot;  &quot;);
        for (int i = 1; i &lt;= cols; i++) {
            System.out.print(&quot; &quot; + CYAN + i + RESET + &quot; &quot;);
        }
        System.out.println(&quot;\n&quot;);
    }

    static boolean placeDisc(char[][] board, int col, char disc) {
        for (int i = board.length - 1; i &gt;= 0; i--) {
            if (board[i][col] == &#x27;.&#x27;) {
                board[i][col] = disc;
                return true;
            }
        }
        return false;
    }

    static boolean checkWin(char[][] board, char disc) {
        int rows = board.length, cols = board[0].length;
        // Horizontal
        for (int r = 0; r &lt; rows; r++)
            for (int c = 0; c &lt;= cols - 4; c++)
                if (board[r][c] == disc &amp;&amp; board[r][c + 1] == disc &amp;&amp; board[r][c + 2] == disc
                        &amp;&amp; board[r][c + 3] == disc)
                    return true;
        // Vertical
        for (int r = 0; r &lt;= rows - 4; r++)
            for (int c = 0; c &lt; cols; c++)
                if (board[r][c] == disc &amp;&amp; board[r + 1][c] == disc &amp;&amp; board[r + 2][c] == disc
                        &amp;&amp; board[r + 3][c] == disc)
                    return true;
        // Diagonal \
        for (int r = 0; r &lt;= rows - 4; r++)
            for (int c = 0; c &lt;= cols - 4; c++)
                if (board[r][c] == disc &amp;&amp; board[r + 1][c + 1] == disc &amp;&amp; board[r + 2][c + 2] == disc
                        &amp;&amp; board[r + 3][c + 3] == disc)
                    return true;
        // Diagonal /
        for (int r = 3; r &lt; rows; r++)
            for (int c = 0; c &lt;= cols - 4; c++)
                if (board[r][c] == disc &amp;&amp; board[r - 1][c + 1] == disc &amp;&amp; board[r - 2][c + 2] == disc
                        &amp;&amp; board[r - 3][c + 3] == disc)
                    return true;
        return false;
    }

    static boolean isFull(char[][] board) {
        for (int c = 0; c &lt; board[0].length; c++)
            if (board[0][c] == &#x27;.&#x27;)
                return false;
        return true;
    }

    static int getBestMove(char[][] board, int depth) {
        int bestScore = Integer.MIN_VALUE;
        int bestCol = 0;
        for (int c = 0; c &lt; board[0].length; c++) {
            if (board[0][c] == &#x27;.&#x27;) {
                char[][] temp = copyBoard(board);
                placeDisc(temp, c, AI);
                int score = minimax(temp, depth - 1, false);
                if (score &gt; bestScore) {
                    bestScore = score;
                    bestCol = c;
                }
            }
        }
        return bestCol;
    }

    static int minimax(char[][] board, int depth, boolean maximizingPlayer) {
        if (checkWin(board, AI))
            return 1000;
        if (checkWin(board, PLAYER))
            return -1000;
        if (isFull(board) || depth == 0)
            return 0;

        if (maximizingPlayer) {
            int maxEval = Integer.MIN_VALUE;
            for (int c = 0; c &lt; board[0].length; c++) {
                if (board[0][c] == &#x27;.&#x27;) {
                    char[][] temp = copyBoard(board);
                    placeDisc(temp, c, AI);
                    maxEval = Math.max(maxEval, minimax(temp, depth - 1, false));
                }
            }
            return maxEval;
        } else {
            int minEval = Integer.MAX_VALUE;
            for (int c = 0; c &lt; board[0].length; c++) {
                if (board[0][c] == &#x27;.&#x27;) {
                    char[][] temp = copyBoard(board);
                    placeDisc(temp, c, PLAYER);
                    minEval = Math.min(minEval, minimax(temp, depth - 1, true));
                }
            }
            return minEval;
        }
    }

    static char[][] copyBoard(char[][] board) {
        char[][] newBoard = new char[board.length][board[0].length];
        for (int i = 0; i &lt; board.length; i++)
            newBoard[i] = board[i].clone();
        return newBoard;
    }

    static void game_mode(Scanner user, int cols, int rows) {
        boolean breaker = true;

        while (breaker) {
            System.out.println(&quot;Excellent! Now choose the Game Mode: \n&quot;);
            System.out.println(&quot;[A]Single Player vs Computer\n&quot;);
            System.out.println(&quot;[B]Two-players\n&quot;);
            System.out.println(&quot;[C]Return to Main Menu\n&quot;);
            String game_mode = user.nextLine();
            if (game_mode.length() != 1) {
                System.err.println(&quot;Invalid input! Please enter only a single character: A, B, or C\n&quot;);
                continue;
            }
            char game_ch = Character.toUpperCase(game_mode.charAt(0));
            switch (game_ch) {
                case &#x27;A&#x27;:
                    playGame(user, cols, rows, true);
                    break;
                case &#x27;B&#x27;:
                    playGame(user, cols, rows, false);
                    break;
                case &#x27;C&#x27;:
                    breaker = false;
                    break;
                default:
                    System.err.println(&quot;Invalid input! Please choose again.&quot;);
            }
        }
    }

    static boolean selectionmenu(Scanner user) {
        System.out.println(&quot;[A]Primary School&quot;);
        System.out.println(&quot;[B]Secondary School&quot;);
        System.out.println(&quot;[C]High School&quot;);
        System.out.println(&quot;[D]University&quot;);
        System.out.println(&quot;[E]Terminate&quot;);
        char charinput = Character.toUpperCase(user.next().charAt(0));
        user.nextLine();
        clearScreen();
        switch (charinput) {
            case &#x27;A&#x27;:
                optionA(user);
                break;
            case &#x27;B&#x27;:
                optionB(user);
                break;
            case &#x27;C&#x27;:
                optionC(user);
                break;
            case &#x27;D&#x27;:
                optionD(user);
                break;
            case &#x27;E&#x27;:
                System.err.println(&quot;Terminating the program...\n&quot;);
                return false;
            default:
                System.err.println(&quot;Invalid input! Please choose again.\n&quot;);
        }
        return true;
    }

    public static void main(String[] args) {
        try (Scanner user = new Scanner(System.in)) {
            boolean breaker = true;

            System.out.println(RED + &quot;   _      _      _      _      _      _      _      _      _      _   &quot; + RESET);
            System.out
                    .println(GREEN + &quot; _( )_  _( )_  _( )_  _( )_  _( )_  _( )_  _( )_  _( )_  _( )_  _( )_ &quot; + RESET);
            System.out
                    .println(YELLOW + &quot;(_ o _)(_ o _)(_ o _)(_ o _)(_ o _)(_ o _)(_ o _)(_ o _)(_ o _)(_ o _)&quot; + RESET);
            System.out.println(BLUE + &quot; (_,_)  (_,_)  (_,_)  (_,_)  (_,_)  (_,_)  (_,_)  (_,_)  (_,_)  (_,_) &quot; + RESET);
            System.out.println(
                    MAGENTA + &quot;   _      | | _  |  _  _ __  _                                    _   &quot; + RESET);
            System.out.println(CYAN + &quot; _( )_    |^|(/_ | (_ (_)|||(/_                                 _( )_ &quot; + RESET);
            System.out
                    .println(WHITE + &quot;(_ o _)                                                        (_ o _)&quot; + RESET);
            System.out.println(RED + &quot; (_,_)    _|_ _    _|_|_  _                                     (_,_) &quot; + RESET);
            System.out
                    .println(GREEN + &quot;   _       |_(_)    |_| |(/_                                      _   &quot; + RESET);
            System.out
                    .println(YELLOW + &quot; _( )_     _        o                                           _( )_ &quot; + RESET);
            System.out.println(BLUE + &quot;(_ o _)   |_) __ _  |  _  _ _|_   /|                           (_ o _)&quot; + RESET);
            System.out.println(
                    MAGENTA + &quot; (_,_)    |   | (_)_| (/_(_  |_    |                            (_,_) &quot; + RESET);
            System.out.println(CYAN + &quot;   _       _           _                             o            _   &quot; + RESET);
            System.out
                    .println(WHITE + &quot; _( )_    (_| __ _    |_)   __  _ __ |_  _  __ _                _( )_ &quot; + RESET);
            System.out.println(RED + &quot;(_ o _)   __| | (_)|_||     |||(/_||||_)(/_ | _&gt;     o         (_ o _)&quot; + RESET);
            System.out
                    .println(GREEN + &quot; (_,_)                                                          (_,_) &quot; + RESET);
            System.out
                    .println(YELLOW + &quot;   _      _      _      _      _      _      _      _      _      _   &quot; + RESET);
            System.out.println(BLUE + &quot; _( )_  _( )_  _( )_  _( )_  _( )_  _( )_  _( )_  _( )_  _( )_  _( )_ &quot; + RESET);
            System.out.println(
                    MAGENTA + &quot;(_ o _)(_ o _)(_ o _)(_ o _)(_ o _)(_ o _)(_ o _)(_ o _)(_ o _)(_ o _)&quot; + RESET);
            System.out.println(CYAN + &quot; (_,_)  (_,_)  (_,_)  (_,_)  (_,_)  (_,_)  (_,_)  (_,_)  (_,_)  (_,_) &quot; + RESET);

            System.out.println(WHITE
                    + &quot; _____                                                                               _____ &quot;);
            System.out.println(
                    &quot;( ___ )-----------------------------------------------------------------------------( ___ )&quot;);
            System.out.println(
                    &quot; |   |                                                                               |   | &quot;);
            System.out.println(
                    &quot; |   |  &quot; + RED + &quot; AA  K  K H  H M   M EEEE DDD      N   N  AA  ZZZZZ  AA  RRRR   OOO  V     V&quot;
                            + WHITE + &quot; |   | &quot;);
            System.out.println(
                    &quot; |   |  &quot; + YELLOW + &quot;A  A K K  H  H MM MM E    D  D     NN  N A  A    Z  A  A R   R O   O V     V&quot;
                            + WHITE + &quot; |   | &quot;);
            System.out.println(
                    &quot; |   |  &quot; + GREEN + &quot;AAAA KK   HHHH M M M EEE  D  D     N N N AAAA   Z   AAAA RRRR  O   O  V   V&quot;
                            + WHITE + &quot;  |   | &quot;);
            System.out.println(
                    &quot; |   |  &quot; + CYAN + &quot;A  A K K  H  H M   M E    D  D     N  NN A  A  Z    A  A R R   O   O   V V&quot;
                            + WHITE + &quot;   |   | &quot;);
            System.out.println(
                    &quot; |   |  &quot; + BLUE + &quot;A  A K  K H  H M   M EEEE DDD      N   N A  A ZZZZZ A  A R  RR  OOO     V&quot;
                            + WHITE + &quot;    |   | &quot;);
            System.out.println(
                    &quot; |   |                                                                               |   | &quot;);
            System.out.println(
                    &quot; |   |                                                                               |   | &quot;);
            System.out.println(&quot; |   |  &quot; + MAGENTA + &quot;K  K U   U  AA  N   N DDD  Y   Y K  K&quot; + WHITE
                    + &quot;                                        |   | &quot;);
            System.out.println(&quot; |   |  &quot; + CYAN + &quot;K K  U   U A  A NN  N D  D  Y Y  K K&quot; + WHITE
                    + &quot;                                         |   | &quot;);
            System.out.println(&quot; |   |  &quot; + YELLOW + &quot;KK   U   U AAAA N N N D  D   Y   KK&quot; + WHITE
                    + &quot;                                          |   | &quot;);
            System.out.println(&quot; |   |  &quot; + GREEN + &quot;K K  U   U A  A N  NN D  D   Y   K K&quot; + WHITE
                    + &quot;                                         |   | &quot;);
            System.out.println(&quot; |   |  &quot; + BLUE + &quot;K  K  UUU  A  A N   N DDD    Y   K  K&quot; + WHITE
                    + &quot;                                        |   | &quot;);
            System.out.println(
                    &quot; |   |                                                                               |   | &quot;);
            System.out.println(
                    &quot; |   |                                                                               |   | &quot;);
            System.out.println(&quot; |   |  &quot; + RED + &quot;K  K Y   Y RRRR  Y   Y K  K BBBB   AA  Y   Y EEEE V     V&quot; + WHITE
                    + &quot;                    |   | &quot;);
            System.out.println(&quot; |   |  &quot; + YELLOW + &quot;K K   Y Y  R   R  Y Y  K K  B   B A  A  Y Y  E    V     V&quot; + WHITE
                    + &quot;                    |   | &quot;);
            System.out.println(&quot; |   |  &quot; + GREEN + &quot;KK     Y   RRRR    Y   KK   BBBB  AAAA   Y   EEE   V   V&quot; + WHITE
                    + &quot;                     |   | &quot;);
            System.out.println(&quot; |   |  &quot; + CYAN + &quot;K K    Y   R R     Y   K K  B   B A  A   Y   E      V V&quot; + WHITE
                    + &quot;                      |   | &quot;);
            System.out.println(&quot; |   |  &quot; + BLUE + &quot;K  K   Y   R  RR   Y   K  K BBBB  A  A   Y   EEEE    V&quot; + WHITE
                    + &quot;                       |   | &quot;);
            System.out.println(
                    &quot; |   |                                                                               |   | &quot;);
            System.out.println(
                    &quot; |   |                                                                               |   | &quot;);
            System.out.println(&quot; |   |  &quot; + MAGENTA + &quot; OOO  M   M III RRRR  BBBB  EEEE K  K&quot; + WHITE
                    + &quot;                                        |   | &quot;);
            System.out.println(&quot; |   |  &quot; + CYAN + &quot;O   O MM MM  I  R   R B   B E    K K&quot; + WHITE
                    + &quot;                                         |   | &quot;);
            System.out.println(&quot; |   |  &quot; + YELLOW + &quot;O   O M M M  I  RRRR  BBBB  EEE  KK&quot; + WHITE
                    + &quot;                                          |   | &quot;);
            System.out.println(&quot; |   |  &quot; + GREEN + &quot;O   O M   M  I  R R   B   B E    K K&quot; + WHITE
                    + &quot;                                         |   | &quot;);
            System.out.println(&quot; |   |  &quot; + BLUE + &quot; OOO  M   M III R  RR BBBB  EEEE K  K&quot; + WHITE
                    + &quot;                                        |   | &quot;);
            System.out.println(
                    &quot; |   |                                                                               |   | &quot;);
            System.out.println(
                    &quot; |   |                                                                               |   | &quot;);
            System.out.println(&quot; |   |  &quot; + RED + &quot;U   U BBBB   AA  III DDD   AA  Y   Y EEEE V     V&quot; + WHITE
                    + &quot;                            |   | &quot;);
            System.out.println(&quot; |   |  &quot; + YELLOW + &quot;U   U B   B A  A  I  D  D A  A  Y Y  E    V     V&quot; + WHITE
                    + &quot;                            |   | &quot;);
            System.out.println(&quot; |   |  &quot; + GREEN + &quot;U   U BBBB  AAAA  I  D  D AAAA   Y   EEE   V   V&quot; + WHITE
                    + &quot;                             |   | &quot;);
            System.out.println(&quot; |   |  &quot; + CYAN + &quot;U   U B   B A  A  I  D  D A  A   Y   E      V V&quot; + WHITE
                    + &quot;                              |   | &quot;);
            System.out.println(&quot; |   |  &quot; + BLUE + &quot; UUU  BBBB  A  A III DDD  A  A   Y   EEEE    V&quot; + WHITE
                    + &quot;                               |   | &quot;);
            System.out.println(
                    &quot; |   |                                                                               |   | &quot;);
            System.out.println(
                    &quot; |   |                                                                               |   | &quot;);
            System.out.println(
                    &quot; |   |  &quot; + MAGENTA + &quot;RRRR   AA  U   U L        III BBBB  RRRR   AA  H  H III M   M  OOO  V     V&quot;
                            + WHITE + &quot;  |   | &quot;);
            System.out.println(
                    &quot; |   |  &quot; + CYAN + &quot;R   R A  A U   U L         I  B   B R   R A  A H  H  I  MM MM O   O V     V&quot;
                            + WHITE + &quot;  |   | &quot;);
            System.out.println(
                    &quot; |   |  &quot; + YELLOW + &quot;RRRR  AAAA U   U L         I  BBBB  RRRR  AAAA HHHH  I  M M M O   O  V   V&quot;
                            + WHITE + &quot;   |   | &quot;);
            System.out.println(
                    &quot; |   |  &quot; + GREEN + &quot;R R   A  A U   U L         I  B   B R R   A  A H  H  I  M   M O   O   V V&quot;
                            + WHITE + &quot;    |   | &quot;);
            System.out.println(
                    &quot; |   |  &quot; + BLUE + &quot;R  RR A  A  UUU  LLLL     III BBBB  R  RR A  A H  H III M   M  OOO     V&quot;
                            + WHITE + &quot;     |   | &quot;);
            System.out.println(
                    &quot; |___|                                                                               |___| &quot;);
            System.out.println(
                    &quot;(_____)-----------------------------------------------------------------------------(_____)&quot;);

            System.out.println(RESET);
            System.out.println(&quot;Hello choose one of these: \n&quot;);
            while (breaker) {
                breaker = selectionmenu(user);
            }
        } catch (Exception e) {
            System.err.println(e);
        }
    }
}</pre>
</main>
</body>
</html>
